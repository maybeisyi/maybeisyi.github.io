<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="你到底在说什么"><meta name="keywords" content="iOS, daiyi"><title>最简单的2个imageView无限轮播器 - 戴奕的个人博客</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/maybeisyi"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">最简单的2个imageView无限轮播器</h1><ul class="meta"><li><i class="icon icon-author"></i>戴奕</li><li><i class="icon icon-clock"></i>12 Minutes</li><li><i class="icon icon-calendar"></i>October 14, 2016</li></ul></div></div><div class="article-content" style="max-width:800px"><h3 id="先讲讲这是个啥东西"><a href="#先讲讲这是个啥东西" class="headerlink" title="先讲讲这是个啥东西"></a>先讲讲这是个啥东西</h3><p><img src="/image/最简单的2个imageView无限轮播器/DYScrollView.gif" alt="无限广告轮播"></p>
<p>就是这个东西，在使用智能手机的年代，基本所有人都看到过这个东西吧。就是左右可以滚动，中间放着广告图片的一个东西。<br><a id="more"></a></p>
<h3 id="这篇文章写给哪些人看"><a href="#这篇文章写给哪些人看" class="headerlink" title="这篇文章写给哪些人看"></a>这篇文章写给哪些人看</h3><p>大神们可以左上角X掉了，本文只阐述最简单的基本原理，没有涉及太多性能优化。没有接触过/实现过/了解过/研究过的同学可以看看，本文讲述的实现原理或许对理解该控件有那么些收益。</p>
<h3 id="DEMO地址"><a href="#DEMO地址" class="headerlink" title="DEMO地址"></a>DEMO地址</h3><p><a href="https://github.com/maybeisyi/DYScrollView" target="_blank" rel="external">https://github.com/maybeisyi/DYScrollView</a><br>尽管下载吧，真的很小很简单，加上一大片注释才100行出头。真是简单的无法自拔了。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>基本实现</li>
</ul>
<p><strong>1.1</strong> 能滚动的东西，不考虑自己实现的情况下，一定是个UIScrollView或子类<code>@property (nonatomic, strong) UIScrollView *scrollView;</code>该属性就是滚动的容器  </p>
<p><strong>1.2</strong> 每次滚动都要显示图片，那就用UIImageView吧（你也可以用UIButton或者任何能够显示图片的View）。  </p>
<p><strong>1.3</strong> 那用几张UIImageView呢？乍一看好像需要显示几张就用几个UIImageView，然后设定scrollView.contentSize的宽度为 (imageView张数 * scrollView宽度)。<br><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a7t8zpudj310k0tyne5.jpg" alt="我是配图"><br>是这样的吗？这样是可以实现一个左右滑动的scrollView，也能够显示所有图片，但是好像有很多缺点啊：  </p>
<p><em>a.</em> 图片的数量是动态变化的，就是说每天都有新广告，所以图片数量不确定，难道我每次加载都要增增减减UIImageView?   </p>
<p><em>b.</em> 滑到最左边或者最右边的图片的时候，不能够再往该方向再滑动了。  </p>
<p><strong>1.4</strong> 怎么解决这两个问题？<br><strong>针对a</strong> 也就是说要设计一个方案来保证UIImageView可以复用，不然你创建过多的UIImageView不是浪费内存么，还忒麻烦，一不小心就数组越界什么的。<br>怎么复用？复用首先想到什么，是UITableViewCell是不是？（cell复用不熟的呵呵）一般情况下cell的个数取决于屏幕上<strong>最多</strong>可显示的cell个数+1。  （最多是指有两个首尾的cell都显示一半）<br>好的，那么我们这里也是一样，屏幕上最多显示2个UIImageView，也就是正在滑动的时候。那么我们创建3个UIImageView就可以完成复用了是吗？是吗？是吗？是的啊，但是这里的复用有点不太一样：三个UIImageView依次排列，中间的UIImageView显示的是正在显示的图片，两边的分别是前后一张图片。<br><img src="http://ww4.sinaimg.cn/mw690/006fcg2Wgw1f9a8fg87bzj310c0u6agb.jpg" alt="我是配图"><br><em>往右滚动了一次</em><br><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a8fgzfqtj311c0tutf7.jpg" alt="我是配图"><br>没有问题吧，这样子一来3个UIImageView就能显示所有的图片了。什么~你说你手指滑的飞快，前面的UIImageView还没跑到广告四的位置，你就滑到了广告四的位置？呵呵，代码都是在主线程里执行的，你能滑到广告四的时候必定执行了我的“换位+换图”代码，如果我的代码没执行完，你的界面是会卡住的（当然iPhone手机平常情况不存在该问题，代码执行速度是人类能抓住的？）  </p>
<p><strong>针对b</strong> 怎么无限滚动？我设个<code>scrollView.contentSize = CGSizeMake(MAXFLOAT, 0);</code>怎么样？第一张往左就滑不出最后一张图片，看样子肯定是要取巧了。仔细想想为什么会无法往两端继续滚动，是不是因为已经滚到了两端，那么如果我们始终不让scrollView滚到两端是不是就能一直左右滚了呢？scrollView有个contentOffset属性，直接改变当前显示的位置（也就是滚动的位置）。好的，如果我们滚到两端的时候瞬间回滚一个UIImageView宽度的距离，再把回滚显示的UIImageView显示的图片“偷梁换柱”成需要显示的图片，是不是就OK了。这个时候好像contentSize也不需要很多了，只需要3个UIImageView的宽度即可，始终显示中间的UIImageView，左右滚动一次，就回滚一次，再把中间的UIImageView换换图片，呵呵，完美。<br><em>初始位置</em><br><img src="http://ww4.sinaimg.cn/mw690/006fcg2Wgw1f9a8yp55yij30re0tgaf2.jpg" alt="我是配图"><br><em>往右滚了一次，刚滚到，还没有偷梁换柱</em><br><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a8ypm8fvj30ss0tk791.jpg" alt="我是配图"><br><em>偷梁换柱~，设定contentOffset为中间的UIImageView，顺便更换这三个UIImageView显示的图片</em><br><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a8yqca7wj30rs0u0jw4.jpg" alt="我是配图"><br>哈哈，已经实现的无限滚动了！并且用户还不知情！  </p>
<p><strong>1.5</strong> 这和标题所说的两个UIImageView不符！其实更节省内存的话，只需要2个UIImageView即可，少开辟一块内存就省一块内存。（虽然7P的内存已达3G，但是作为程序员，对自己要求更高一点嘛）<br><em>怎么整</em> 刚才两边都有图片的原因是两边确实有两个UIImageView显示在那里，实实在在的，拖过去就是它，就在那！能不显示吗？不过，还记得上文说过的，这些UI代码都是在主线程执行，我们可以在用户滑过去之前干点事，那就是：判断用户滑动方向，往哪滑我就把第二个UIImageView拼接在哪个方向。<br><em>初始位置</em><br><img src="http://ww4.sinaimg.cn/mw690/006fcg2Wgw1f9a97zxhw3j30so0xm444.jpg" alt="我是配图"><br><em>往右滚了一点，赶紧判断是哪方向，把第二个UIImageView拼接上去并显示成下一个图</em><br><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a9811bgsj30sa0ua43h.jpg" alt="我是配图"><br><em>往左也是一样的</em><br><img src="http://ww2.sinaimg.cn/mw690/006fcg2Wgw1f9a981rotcj30rg0tu43a.jpg" alt="我是配图"><br>大功告成  </p>
<h3 id="现在结合代码来看看"><a href="#现在结合代码来看看" class="headerlink" title="现在结合代码来看看"></a>现在结合代码来看看</h3><p><code>_currentPage</code>是当前显示第几张图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** 当前滚动方向 */</div><div class="line">typedef NS_ENUM(NSInteger, ScrollDirection) &#123;</div><div class="line">    ScrollDirectionUnknow,</div><div class="line">    ScrollDirectionLeft,</div><div class="line">    ScrollDirectionRight</div><div class="line">&#125;;</div><div class="line">/** 滚动方向 */</div><div class="line">@property (nonatomic, assign) ScrollDirection scrollDirection;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</div><div class="line">    /** 判断一下此时是向右滚动还是向左滚动，根据设想，停止时的scrollView显示的内容永远是中间，那么scrollView.contentOffset.x 应该永远是 scrollView.frame.size.width，这里就是SCREEN_WIDTH。那么在动的时候通过scrollView.contentOffset.x 就可以知道是向哪个方向滚动</div><div class="line">     </div><div class="line">     性能优化：1. 该方法在滚动过程中重复调用，向左向右滑动其实在改变时赋值即可，后续无需判断？  ——&gt;利用self.scrollDirection进方向判断来优化判断逻辑</div><div class="line">     2._otherImageView 反复调用 setFrame 和 setImage 方法，是否会有损性能？ ——&gt;利用self.scrollDirection进方向判断来优化判断逻辑</div><div class="line">     */</div><div class="line">    if (scrollView.contentOffset.x &gt; SCREEN_WIDTH) &#123;</div><div class="line">        </div><div class="line">        if (self.scrollDirection == ScrollDirectionUnknow || self.scrollDirection == ScrollDirectionLeft) &#123;</div><div class="line">            NSLog(@&quot;向右滚动&quot;);</div><div class="line">            </div><div class="line">            // 向右滚动则要把另一张图片放在右边</div><div class="line">            _otherImageView.frame = CGRectMake(_currentImageView.frame.origin.x + SCREEN_WIDTH, 0, SCREEN_WIDTH, 250);</div><div class="line">            </div><div class="line">            // 同时给这个imageView上图片</div><div class="line">            if (_currentPage == _imageArr.count - 1) &#123;</div><div class="line">                _otherImageView.image = _imageArr[0];</div><div class="line">            &#125; else &#123;</div><div class="line">                _otherImageView.image = _imageArr[_currentPage + 1];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            self.scrollDirection = ScrollDirectionRight;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (scrollView.contentOffset.x &lt; SCREEN_WIDTH) &#123;</div><div class="line">        </div><div class="line">        if (self.scrollDirection == ScrollDirectionUnknow || self.scrollDirection == ScrollDirectionRight) &#123;</div><div class="line">            NSLog(@&quot;向左滚动&quot;);</div><div class="line"></div><div class="line">            // 同理向左</div><div class="line">            _otherImageView.frame = CGRectMake(_currentImageView.frame.origin.x - SCREEN_WIDTH, 0, SCREEN_WIDTH, 250);</div><div class="line">            if (_currentPage == 0) &#123;</div><div class="line">                _otherImageView.image = _imageArr[_imageArr.count - 1];</div><div class="line">            &#125; else &#123;</div><div class="line">                _otherImageView.image = _imageArr[_currentPage - 1];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            self.scrollDirection = ScrollDirectionLeft;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        self.scrollDirection = ScrollDirectionUnknow;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 重置图像，就是把otherImageView拉到中间全部显示的时候，赶紧换currentImageView来显示，即把scrollView.contentOffset.x 又设置到原来的位置，那么_currentImageView又能够全部显示了，但是_currentImageView显示的上一张/下一张的图片，需要替换成当前图片。进入该判断次数不多</div><div class="line">    if (scrollView.contentOffset.x &gt;= SCREEN_WIDTH * 2) &#123;</div><div class="line">        NSLog(@&quot;向右越界&quot;);</div><div class="line">        if (_currentPage == 4) &#123;</div><div class="line">            _currentPage = 0;</div><div class="line">        &#125; else &#123;</div><div class="line">            _currentPage++;</div><div class="line">        &#125;</div><div class="line">        _currentImageView.image = _imageArr[_currentPage];</div><div class="line">        scrollView.contentOffset = CGPointMake(SCREEN_WIDTH, 0);</div><div class="line">    &#125; else if (scrollView.contentOffset.x &lt;= 0) &#123;</div><div class="line">        NSLog(@&quot;向左越界&quot;);</div><div class="line">        if (_currentPage == 0) &#123;</div><div class="line">            _currentPage = 4;</div><div class="line">        &#125; else &#123;</div><div class="line">            _currentPage--;</div><div class="line">        &#125;</div><div class="line">        _currentImageView.image = _imageArr[_currentPage];</div><div class="line">        scrollView.contentOffset = CGPointMake(SCREEN_WIDTH, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一共50行代码，中间还有一大串注释，就这么easy。  </p>
<p><code>scrollDirection</code>这个变量是性能优化用的。如果没有这个变量，只能单纯依靠contentOffset.x 与 SCREEN_WIDTH的关系判定是左滑还是右滑了。</p>
<p>那么在scrollViewDidScroll:里面就会重复执行很多遍setFrame 和 setImage 方法，对性能是有损耗的。但是利用了这个枚举变量，只需要执行两个枚举变量的判断（整形的判断），不涉及对象操作，也就能将性能损耗降到最低了。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">5</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj1j27oz50006k0vslir1e4ey" data-title="最简单的2个imageView无限轮播器" data-url="http://yoursite.com/2016/10/14/最简单的2个imageView无限轮播器/" site-name="daiyi"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2016/10/14/你对@synthesize混淆了吗？/"><i class="icon icon-arror-left"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/maybeisyi" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/5721363654/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="mailto:daybyte@163.com" title="Email" target="_blank"><i class="icon icon-email"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 戴奕的个人博客<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>