<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="你到底在说什么"><meta name="keywords" content="iOS, daiyi"><title>最简单的2个imageView实现Banner - 戴奕的个人博客</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/maybeisyi"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">最简单的2个imageView实现Banner</h1><ul class="meta"><li><i class="icon icon-author"></i>戴奕</li><li><i class="icon icon-clock"></i>13 Minutes</li><li><i class="icon icon-calendar"></i>October 14, 2016</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="先讲讲这是个啥东西"><a href="#先讲讲这是个啥东西" class="headerlink" title="先讲讲这是个啥东西"></a>先讲讲这是个啥东西</h2><p><img src="/image/最简单的2个imageView无限轮播器/DYScrollView.gif" alt="无限广告轮播"></p>
<p>就是这个东西，在使用智能手机的年代，基本所有人都看到过这个东西吧。就是左右可以滚动，中间放着广告图片的一个东西。<br><a id="more"></a></p>
<h2 id="这篇文章写给哪些人看"><a href="#这篇文章写给哪些人看" class="headerlink" title="这篇文章写给哪些人看"></a>这篇文章写给哪些人看</h2><p>大神们可以左上角X掉了，本文只阐述最简单的基本原理，只有小部分的性能优化讲解。没有接触过/实现过/了解过的同学可以看看，本文讲述的实现原理或许对理解该控件有些收益。</p>
<h2 id="DEMO地址"><a href="#DEMO地址" class="headerlink" title="DEMO地址"></a>DEMO地址</h2><p><a href="https://github.com/maybeisyi/DYScrollView" target="_blank" rel="external">https://github.com/maybeisyi/DYScrollView</a></p>
<p>尽管下载吧，真的很小很简单，加上一大片注释才100行出头。真是简单的无法自拔了。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p><strong>1.1</strong> 能滚动的东西，不考虑自己实现的情况下，一定是个UIScrollView或UIScrollView的子类，<code>@property (nonatomic, strong) UIScrollView *scrollView;</code>该属性就是滚动用的容器。</p>
<p><strong>1.2</strong> 需要在UIScrollView上显示图片，那就用UIImageView吧（你也可以用UIButton或者任何能够显示图片的View）。</p>
<p><strong>1.3</strong> 那用几张UIImageView呢？乍一看好像要显示几张广告就用几个UIImageView，然后设定scrollView.contentSize的宽度为（imageView张数 * scrollView宽度）。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a7t8zpudj310k0tyne5.jpg" alt="我是配图"></p>
<p>是这样的吗？这样是可以实现一个左右滑动的scrollView，也能够显示所有图片，但是好像有很多缺点啊：  </p>
<p><em>a.</em> 图片的数量是动态变化的，就是说每天都有新广告，所以图片数量不确定，难道我每次重新加载都要增增减减UIImageView? </p>
<p><em>b.</em> 滑到第一张或者最后一张图片的时候，不能够再往左/右方向滑动出下一张图片了。  </p>
<p><strong>1.4</strong> 怎么解决这两个问题？</p>
<p><strong>针对a</strong> 也就是说要设计一个方案来保证UIImageView可以复用，不然你创建过多的UIImageView不是浪费内存么，还忒麻烦，一不小心就数组越界什么的。</p>
<p>怎么复用imageView呢？想象我们的Banner，当静止的时候，中间显示的广告imageView（广告二），两边都是各有一张imageView（广告一和广告三）的，当我滚到下一张的时候，两边还是有imageView的。</p>
<ul>
<li>假设我们是手指往左拖动，将<strong>广告三</strong>拖到了正中间进行展示，那么在原先静止的imageView（广告二）左边的那个imageView（广告一）是否已经完全脱离屏幕了？</li>
<li>因为此时广告三左边是<strong>广告二</strong>，右边是<strong>广告四</strong>，我左右拖动广告三都是看不见<strong>广告一</strong>的，所以这个时候的<strong>广告一</strong>就是那个被重用的imageView，广告三右边的<strong>广告四</strong>就可以顺利成章复用原先的<strong>广告一</strong>了。</li>
<li>当然在复用<strong>广告一</strong>的imageView的同时还得将图片改为广告四。</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/mw690/006fcg2Wgw1f9a8fg87bzj310c0u6agb.jpg" alt="我是配图"></p>
<p><em>手指往左拖一次（往右滚动了一次）</em>（图片有误，当前Banner展示的是广告三）</p>
<p><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a8fgzfqtj311c0tutf7.jpg" alt="我是配图"></p>
<p>没有问题吧，这样子一来3个UIImageView就能显示所有的图片了。什么~你说你手指滑的飞快，前面的UIImageView还没跑到广告四的位置，你就滑到了广告四的位置？呵呵，代码都是在主线程里执行的，你能滑到广告四的时候必定执行了我的“换位+换图”代码，如果我的代码没执行完，你的界面是会卡住的（当然iPhone手机平常情况不存在该问题，代码执行速度是人类能抓住的？）  。</p>
<p><strong>针对b</strong> 怎么无限滚动？我设个<code>scrollView.contentSize = CGSizeMake(MAXFLOAT, 0);</code>怎么样？这样第一张往左就不能滚动了，看样子肯定是要取巧了。仔细想想为什么会无法往两端继续滚动，是不是因为已经滚到了两端，那么如果我们始终不让scrollView滚到两端是不是就能一直左右滚了呢？scrollView有个contentOffset属性，直接改变当前显示的位置（也就是滚动的位置）。好的，如果我们滚到两端的时候瞬间回滚一个UIImageView宽度的距离，再把回滚显示的UIImageView显示的图片“偷梁换柱”成需要显示的图片，是不是就OK了。这个时候好像contentSize也不需要很多了，只需要3个UIImageView的宽度即可，始终显示中间的UIImageView，左右滚动一次，就回滚一次，显示中间的imageView，再把中间的UIImageView换成需要正确显示的图片，呵呵，完美。</p>
<p><em>初始位置</em>（图片有误，当前Banner展示的是广告一）</p>
<p><img src="http://ww4.sinaimg.cn/mw690/006fcg2Wgw1f9a8yp55yij30re0tgaf2.jpg" alt="我是配图"></p>
<p><em>往右滚了一次，刚滚到，还没有偷梁换柱</em></p>
<p><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a8ypm8fvj30ss0tk791.jpg" alt="我是配图"></p>
<p><em>瞬间偷梁换柱~，设定contentOffset为中间的UIImageView，顺便更换这三个UIImageView显示的图片</em></p>
<p><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a8yqca7wj30rs0u0jw4.jpg" alt="我是配图"></p>
<p>哈哈，已经实现的无限滚动了！并且用户还不知情！</p>
<p><strong>1.5</strong> 但是这个方案这和标题所说的两个UIImageView不符！其实更节省内存的话，只需要2个UIImageView即可，少开辟一块内存就省一块内存。（虽然7P的内存已达3G，但是作为“程序员里的工程师”…）</p>
<p><strong><em>怎么整？</em></strong> 刚才中间显示的imageView两边都有一个imageView的原因是两边确实有两个UIImageView显示在那里，实实在在的，往左往右滑动都能显示出来，就在那！能不显示吗？不过，让我们先来回顾一个系统控件：<code>UITableView</code>。</p>
<p><code>UITableView</code>里的cell重用机制各位应该了解（必须了解），最多创建cell的个数是屏幕上最多显示的cell的个数，这个最多一般就是手指上下拖动的时候，第一个cell只显示了下半部分，屏幕下端也刚出现了新的cell的上半部分，这个时候是<strong>同时显示在屏幕上的cell个数最多</strong>的时候。</p>
<p>对比我们的Banner，我们的屏幕上，最多展示的广告个数，就是拖动的时候：2个。无论往左还是往右拖，最多都是2个imageView，那么我们只需要2个imageView就足够复用了：一个是当前显示的imageView，另一个是待在“重用池”里待命的imageView。这个待命的imageView只有在一个时候发挥作用：手指拖动时，add到屏幕上告诉用户，看，这里有个imageView。</p>
<p>还记得上文说过的，我们的UI代码都是在主线程执行，我们可以在用户滑动时干点事，那就是：判断用户滑动方向，往哪滑我就把第二个UIImageView（重用池里的那个）拼接在哪个方向。</p>
<p><em>初始位置</em>（图片有误，当前Banner展示的是广告一）<br><img src="http://ww4.sinaimg.cn/mw690/006fcg2Wgw1f9a97zxhw3j30so0xm444.jpg" alt="我是配图"></p>
<p><em>往右滚了一点，赶紧判断是哪方向，把第二个UIImageView拼接上去并显示成下一个图</em>（图片有误，当前Banner展示的是广告一）</p>
<p><img src="http://ww3.sinaimg.cn/mw690/006fcg2Wgw1f9a9811bgsj30sa0ua43h.jpg" alt="我是配图"></p>
<p><em>往左也是一样的</em>（图片有误，当前Banner展示的是广告一）</p>
<p><img src="http://ww2.sinaimg.cn/mw690/006fcg2Wgw1f9a981rotcj30rg0tu43a.jpg" alt="我是配图"></p>
<p><strong>大功告成 !</strong></p>
<h3 id="现在结合代码来看看"><a href="#现在结合代码来看看" class="headerlink" title="现在结合代码来看看"></a>现在结合代码来看看</h3><p><code>_currentPage</code>是当前显示第几张图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/** 当前滚动方向 */</div><div class="line">typedef NS_ENUM(NSInteger, ScrollDirection) &#123;</div><div class="line">    ScrollDirectionUnknow,</div><div class="line">    ScrollDirectionLeft,</div><div class="line">    ScrollDirectionRight</div><div class="line">&#125;;</div><div class="line">/** 滚动方向 */</div><div class="line">@property (nonatomic, assign) ScrollDirection scrollDirection;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</div><div class="line">    /** 判断一下此时是向右滚动还是向左滚动，根据设想，停止时的scrollView显示的内容永远是中间，那么scrollView.contentOffset.x 静止时应该是 scrollView.frame.size.width，这里就是SCREEN_WIDTH这个宏。那么在滚动的时候通过scrollView.contentOffset.x 就可以知道是向哪个方向滚动</div><div class="line">     */</div><div class="line">    if (scrollView.contentOffset.x &gt; SCREEN_WIDTH) &#123;</div><div class="line">        </div><div class="line">        if (_scrollDirection == ScrollDirectionUnknow || _scrollDirection == ScrollDirectionLeft) &#123;</div><div class="line">            NSLog(@&quot;向右滚动&quot;);</div><div class="line">            </div><div class="line">            // 向右滚动则要把另一张图片放在右边</div><div class="line">            _otherImageView.frame = CGRectMake(_currentImageView.frame.origin.x + SCREEN_WIDTH, 0, SCREEN_WIDTH, 250);</div><div class="line">            </div><div class="line">            // 同时给这个imageView上图片</div><div class="line">            if (_currentPage == _imageArr.count - 1) &#123;</div><div class="line">                _otherImageView.image = _imageArr[0];</div><div class="line">            &#125; else &#123;</div><div class="line">                _otherImageView.image = _imageArr[_currentPage + 1];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // 设定方向（用来性能优化的点）</div><div class="line">            _scrollDirection = ScrollDirectionRight;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (scrollView.contentOffset.x &lt; SCREEN_WIDTH) &#123;</div><div class="line">        </div><div class="line">        if (_scrollDirection == ScrollDirectionUnknow || _scrollDirection == ScrollDirectionRight) &#123;</div><div class="line">            NSLog(@&quot;向左滚动&quot;);</div><div class="line"></div><div class="line">            // 同理向左</div><div class="line">            _otherImageView.frame = CGRectMake(_currentImageView.frame.origin.x - SCREEN_WIDTH, 0, SCREEN_WIDTH, 250);</div><div class="line">            if (_currentPage == 0) &#123;</div><div class="line">                _otherImageView.image = _imageArr[_imageArr.count - 1];</div><div class="line">            &#125; else &#123;</div><div class="line">                _otherImageView.image = _imageArr[_currentPage - 1];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // 设定方向（用来性能优化的点）</div><div class="line">            _scrollDirection = ScrollDirectionLeft;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        _scrollDirection = ScrollDirectionUnknow;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 重置图像，就是把otherImageView拉到中间全部显示的时候，赶紧换currentImageView来显示，即把scrollView.contentOffset.x 又设置到原来的位置，那么_currentImageView又能够全部显示了，但是_currentImageView显示的上一张/下一张的图片，需要替换成当前图片。进入该判断次数不多</div><div class="line">    if (scrollView.contentOffset.x &gt;= SCREEN_WIDTH * 2) &#123;</div><div class="line">        NSLog(@&quot;向右越界&quot;);</div><div class="line">        if (_currentPage == 4) &#123;</div><div class="line">            _currentPage = 0;</div><div class="line">        &#125; else &#123;</div><div class="line">            _currentPage++;</div><div class="line">        &#125;</div><div class="line">        _currentImageView.image = _imageArr[_currentPage];</div><div class="line">        scrollView.contentOffset = CGPointMake(SCREEN_WIDTH, 0);</div><div class="line">    &#125; else if (scrollView.contentOffset.x &lt;= 0) &#123;</div><div class="line">        NSLog(@&quot;向左越界&quot;);</div><div class="line">        if (_currentPage == 0) &#123;</div><div class="line">            _currentPage = 4;</div><div class="line">        &#125; else &#123;</div><div class="line">            _currentPage--;</div><div class="line">        &#125;</div><div class="line">        _currentImageView.image = _imageArr[_currentPage];</div><div class="line">        scrollView.contentOffset = CGPointMake(SCREEN_WIDTH, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一共50行代码，中间还有一大串注释，就这么easy。  </p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="假设没有scrollDirection变量"><a href="#假设没有scrollDirection变量" class="headerlink" title="假设没有scrollDirection变量"></a>假设没有<code>scrollDirection</code>变量</h3><p>如果没有该变量，那么<code>scrollViewDidScroll:</code>方法里必须判断<code>_otherImageView</code>是否放在了<code>_currentImageView</code>的右边/左边，那么也就是判断<code>_otherImageView</code>的frame.x与<code>_currentImageView</code>的位置之间的关系，这将会给两个对象发送<code>- (CGRect)frame;</code>消息，再进行数值比较。</p>
<h3 id="有了scrollDirection变量"><a href="#有了scrollDirection变量" class="headerlink" title="有了scrollDirection变量"></a>有了<code>scrollDirection</code>变量</h3><p>有了该变量，我们只需要用该变量记录当前滚动方向，直接用该值进行比较，而无需在两个对象中发送消息取值再进行比较。这样也就能将性能提升到最优。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">5</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj22y9v5u0004fxvso47dhqlp" data-title="最简单的2个imageView实现Banner" data-url="http://yoursite.com/2016/10/14/MostSimpleBanner/" site-name="daiyi"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2016/10/14/DoYouConfuse@synthesize/"><i class="icon icon-arror-left"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/maybeisyi" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/5721363654/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="mailto:daybyte@163.com" title="Email" target="_blank"><i class="icon icon-email"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 戴奕的个人博客<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>