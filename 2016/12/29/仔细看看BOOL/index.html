<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="你到底在说什么"><meta name="keywords" content="iOS, daiyi"><title>仔细看看你的BOOL - 戴奕的个人博客</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/maybeisyi"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">仔细看看你的BOOL</h1><ul class="meta"><li><i class="icon icon-author"></i>戴奕</li><li><i class="icon icon-clock"></i>3 Minutes</li><li><i class="icon icon-calendar"></i>December 29, 2016</li></ul></div></div><div class="article-content" style="max-width:800px"><h3 id="为啥要看这玩意"><a href="#为啥要看这玩意" class="headerlink" title="为啥要看这玩意"></a>为啥要看这玩意</h3><p>越是每天在用的东西你越可能忽略它，所以当你碰到一些莫名其妙的bug的时候，你可能真的是莫名其妙了。所以偶尔回头看看还是很有必要的~<br><a id="more"></a></p>
<h3 id="BOOL的定义"><a href="#BOOL的定义" class="headerlink" title="BOOL的定义"></a>BOOL的定义</h3><pre><code class="iOS">/// Type to represent a boolean value.
#if (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH
#define OBJC_BOOL_IS_BOOL 1
typedef bool BOOL;
#else
#define OBJC_BOOL_IS_CHAR 1
typedef signed char BOOL; 
// BOOL is explicitly signed so @encode(BOOL) == &quot;c&quot; rather than &quot;C&quot; 
// even if -funsigned-char is used.
#endif
</code></pre>
<p>伪代码解释下：  </p>
<p>if (处于64位iPhone 或者 iWatch) {<br>　　BOOL就是bool  （非0即真）<br>} else {<br>　　BOOL就是signed char  （1个字节，取低8位。-128 ~ 127）<br>}  </p>
<p>这里的else，最常见的就是32位架构的iPhone，比如iPhone5c/5/4s/4等。<br>定义里可以看出，BOOL你原来是个宏啊，亏你还是OC中的基本数据类型~ 真是给宏长脸了啊。  </p>
<hr>
<p>这里就引申出一个可能存在的问题：</p>
<pre><code class="iOS">- (void)doSomeThingWithA:(NSInteger)a {
    NSInteger b = 28;
    if (a + b) {
        // 业务代码
    }
}
</code></pre>
<p>乍看之下，这段代码只要 <code>a != -28</code>，都是能够执行业务代码部分。在64位iPhone和iWatch机器里确实是如此，因为定义的BOOL就是bool，就是非0即真，你用负数也是真。<br>但是在32位机器里呢？如果a传入100，<code>a + b == 128</code>，二进制是  1000 0001 0000 0000 0000 0000 0000 0000（因为32位里NSInteger是int【话说最新的头文件定义里多了个<code>NS_BUILD_32_LIKE_64</code>，估计编译器可以设置32位的机器以64位来进行编译，这个这里暂时不展开讨论】，占用4个字节，每个字节8位嘛）。该数会强转为sign char，：取低8位 0000 0000 来判断。if中判定为0，则为假，不再执行业务代码。</p>
<h3 id="YES-NO的定义"><a href="#YES-NO的定义" class="headerlink" title="YES / NO的定义"></a>YES / NO的定义</h3><p>说到了BOOL，肯定要说说YES / NO。<br>老板，上代码：</p>
<pre><code class="iOS">#if __has_feature(objc_bool)
#define YES __objc_yes
#define NO  __objc_no
#else
#define YES ((BOOL)1)
#define NO  ((BOOL)0)
#endif
</code></pre>
<p>这两玩意也是宏。这里定义了YES / NO在不同条件下的真实类型。上述的<code>objc_bool</code>暂时还没有找到具体在哪定义，个人猜测意思应该是BOOL为bool的时候。否则YES / NO 即为sign char中的1和0。  </p>
<hr>
<p>所以这里又来了个老生常谈的问题：不要拿数值和 YES / NO 的比较作为条件判断，如<code>if (a + b == YES)</code>。</p>
<h3 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h3><p>我们来看看C99中的bool定义（刨根就要刨的深一点）：</p>
<pre><code class="iOS">#ifndef __STDBOOL_H
#define __STDBOOL_H

/* Don&apos;t define bool, true, and false in C++, except as a GNU extension. */
#ifndef __cplusplus
#define bool _Bool
#define true 1
#define false 0
#elif defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__)
/* Define _Bool, bool, false, true as a GNU extension. */
#define _Bool bool
#define bool  bool
#define false false
#define true  true
#endif

#define __bool_true_false_are_defined 1

#endif /* __STDBOOL_H */
</code></pre>
<p>这是stdbool.h中的bool的定义（C99标准）。<br>bool其实还是个宏（又一次给宏长脸）。真实类型为_Bool。_Bool其实是占1个字节的一种类型，1为真，0为假。定义中的true与false分别等于1和0也说明了这一点。<br>而如果有别的数值转换为bool类型（_Bool），则非0的所有数值均转化为1，正是这点，让bool类型在128时也能判断为真。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了看清bool与BOOL，挖了不少C中的头文件，宏真的是个好东西，真的很长脸~<br>可能这些知识在你平时开发中，遇上10000个bug才会派上用场一次。但是越是了解这些细微的、基础的知识，对程序本质的理解也就越清晰。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">5</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj1c824ub0002xqvs2zjfbow3" data-title="仔细看看你的BOOL" data-url="http://yoursite.com/2016/12/29/仔细看看BOOL/" site-name="daiyi"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/01/07/二级指针与ARC不为人知的特性/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2016/12/29/第一份工作总结/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/maybeisyi" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/5721363654/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="mailto:daybyte@163.com" title="Email" target="_blank"><i class="icon icon-email"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 戴奕的个人博客<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>