<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="你到底在说什么"><meta name="keywords" content="iOS, daiyi"><title>super关键字帮我们做了什么？ - 戴奕的个人博客</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/maybeisyi"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">super关键字帮我们做了什么？</h1><ul class="meta"><li><i class="icon icon-author"></i>戴奕</li><li><i class="icon icon-clock"></i>37 Minutes</li><li><i class="icon icon-calendar"></i>May 18, 2017</li></ul></div></div><div class="article-content" style="max-width:800px"><p>本篇文章讲的是super的实际运作原理，如有同学对super与self的区分还有疑惑的，请参考ChenYilong大神的<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#21-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88" target="_blank" rel="external">《招聘一个靠谱的iOS》面试题参考答案（上）</a>。</p>
<a id="more"></a>
<h2 id="super究竟在干什么？"><a href="#super究竟在干什么？" class="headerlink" title="super究竟在干什么？"></a>super究竟在干什么？</h2><h3 id="官方提到的super关键字？"><a href="#官方提到的super关键字？" class="headerlink" title="官方提到的super关键字？"></a>官方提到的super关键字？</h3><p>打开苹果API文档，搜索<code>objc_msgSendSuper</code>（对该函数陌生的先去补补rumtime）。</p>
<p><img src="/image/super-keyword/superKeywordDefine.png" alt="super官方解释"></p>
<p>里面明确提到了使用<code>super</code>关键字发送消息会被编译器转化为调用<code>objc_msgSendSuper</code>以及相关函数（由返回值决定）。</p>
<p>再让我们看看该函数的定义（这是文档中的定义）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...);</div></pre></td></tr></table></figure>
<p>这里的<code>super</code>已经不再是我们调用时写的<code>[super init]</code>的<code>super</code>了，这里指代的是<code>struct objc_super</code>结构体指针。文档中明确指出，该结构体需要包含<strong>接收消息的实例</strong>以及<strong>一开始寻找方法实现的父类</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct objc_super &#123;</div><div class="line">    /// Specifies an instance of a class.</div><div class="line">    __unsafe_unretained id receiver;</div><div class="line"></div><div class="line">    /// Specifies the particular superclass of the instance to message. </div><div class="line">    __unsafe_unretained Class super_class;</div><div class="line">    /* super_class is the first class to search */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="/image/super-keyword/objc_superDefine.png" alt="objc_super结构体"></p>
<p>既然知道了<code>super</code>是如何调用的，那么我们来尝试自己实现一个<code>super</code>。</p>
<h3 id="手动实现super关键字"><a href="#手动实现super关键字" class="headerlink" title="手动实现super关键字"></a>手动实现super关键字</h3><p>让我们先定义两个类：</p>
<p>这是父类：Father类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Father.h</div><div class="line">@interface Father : NSObject</div><div class="line">  </div><div class="line">- (void)eat;</div><div class="line"></div><div class="line">@end</div><div class="line">  </div><div class="line">// Father.m</div><div class="line">@implementation Father</div><div class="line"></div><div class="line">- (void)eat &#123;</div><div class="line">    NSLog(@&quot;Father eat&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这是子类：Son类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Son.h</div><div class="line">@interface Son : Father</div><div class="line"></div><div class="line">- (void)eat;</div><div class="line"></div><div class="line">@end</div><div class="line">  </div><div class="line">// Son.m</div><div class="line">@implementation Son</div><div class="line"></div><div class="line">- (void)eat &#123;</div><div class="line">    [super eat];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在这里，我们的Son类重写了父类的<code>eat</code>方法，里面只做一件事，就是调用父类的<code>eat</code>方法。</p>
<p>让我们在main中开始进行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    Son *son = [Son new];</div><div class="line">    [son eat];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 输出：</div><div class="line">2017-05-14 22:44:00.208931+0800 TestSuper[7407:3788932] Father eat</div></pre></td></tr></table></figure>
<p>到这里没毛病，一个Son对象调用了<code>eat</code>方法（内部调用父类的<code>eat</code>），输出了结果。</p>
<h4 id="1-下面，我们来自己实现super的效果："><a href="#1-下面，我们来自己实现super的效果：" class="headerlink" title="1. 下面，我们来自己实现super的效果："></a>1. 下面，我们来自己实现<code>super</code>的效果：</h4><p>改写Son.m：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Son.m</div><div class="line"></div><div class="line">- (void)eat &#123;</div><div class="line">//    [super eat];</div><div class="line">    </div><div class="line">    struct objc_super superReceiver = &#123;</div><div class="line">        self,</div><div class="line">        [self superclass]</div><div class="line">    &#125;;</div><div class="line">    objc_msgSendSuper(&amp;superReceiver, _cmd);    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行我们的main函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//输出</div><div class="line">2017-05-14 22:47:00.109379+0800 TestSuper[7417:3790621] Father eat</div></pre></td></tr></table></figure>
<p>没毛病，我们可是根据官方文档来实现<code>super</code>的效果。</p>
<p>难道<code>super</code>真的就是如此？</p>
<p>让我们持怀疑的态度看看下面这个例子：</p>
<p>在这里，我们又有个Son的子类出现了：Grandson类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// Grandson.h</div><div class="line">@interface Grandson : Son</div><div class="line"></div><div class="line">@end</div><div class="line">  </div><div class="line">// Grandson.m</div><div class="line">@implementation Grandson</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>该类啥什么都没实现，纯粹继承自Son。</p>
<p>然后让我们改写main函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    Grandson *grandson = [Grandson new];</div><div class="line">    [grandson eat];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行起来，过一会就crash了，如图：</p>
<p><img src="/image/super-keyword/crash1.png" alt="崩溃提示"></p>
<p>再看看相关线程中的方法调用：</p>
<p><img src="/image/super-keyword/crashThread.png" alt="crash方法调用"></p>
<p>这是一个死循环，所以系统让该段代码强制停止了。可为什么这里会构成死循环呢？让我们好好分析分析：</p>
<ol>
<li>Grandson中没有实现eat方法，所以main函数中Grandson的实例执行eat方法是这样的：根据类继承关系自下而上寻找，在Grandson的父类Son类中找到了eat方法，进行调用。</li>
<li>在Son的eat方法的实现中，我们构建了一个<code>superReceiver</code>结构体，内部包含了<code>self</code>以及<code>[self superclass]</code>。在调用过程中，self指代的应是Grandson实例，也就是grandson这个变量，那么<code>[self superclass]</code>方法返回值也就是Son这个类。</li>
<li>根据第2点的分析，以及我们在文章开头的文档中，苹果指出<code>superReceiver</code>中的父类就是开始寻找方法实现的那个父类，我们可以得出，此时的<code>objc_msgSendSuper(&amp;superReceiver, _cmd)</code>函数调用的方法实现即是Son类中的<code>eat</code>方法的实现。即，构成了递归。</li>
</ol>
<p>既然这里不能使用<code>superclass</code>方法，那么我们要如何自己实现<code>super</code>的作用呢？</p>
<p>我们是这段代码的作者，所以，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 我们修改了Son.m</div><div class="line"></div><div class="line">- (void)eat &#123;</div><div class="line">//    [super eat];</div><div class="line">    </div><div class="line">    struct objc_super superReceiver = &#123;</div><div class="line">        self,</div><div class="line">        objc_getClass(&quot;Father&quot;)</div><div class="line">    &#125;;</div><div class="line">    objc_msgSendSuper(&amp;superReceiver, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 输出</div><div class="line">2017-05-14 23:16:49.232375+0800 TestSuper[7440:3798009] Father eat</div></pre></td></tr></table></figure>
<p>我们直接指明<code>superReceiver</code>中要寻找方法实现的父类：Father。这里必定有人会问：这样子岂不是每个调用<code>[super xxxx]</code>的地方都需要直接指明<strong>父类</strong>？</p>
<blockquote>
<p>“直接指明”的意思是，代码中直接写出这个类，比如直接写：<code>[Father class]</code>或者<code>objc_getClass(&quot;Father&quot;)</code>，这里面的Father与”Father”就是我们在代码里写死的。</p>
</blockquote>
<p>先不谈这个疑问，我们来分析这段代码：</p>
<ol>
<li>Grandson中没有实现eat方法，所以main函数中Grandson的实例执行eat方法是这样的：根据类继承关系自下而上寻找，在Grandson的父类Son类中找到了eat方法，进行调用。</li>
<li>在Son的eat方法的实现中，我们构建了一个<code>superReceiver</code>结构体，内部包含了<code>self</code>以及<code>Father</code>这个类。</li>
<li><code>objc_msgSendSuper</code>函数直接去Father类中寻找<code>eat</code>方法的实现，并执行（输出）。</li>
</ol>
<p>现在这段代码是以正常逻辑执行的。</p>
<h4 id="2-super-xxxx-真的要直接指明父类？"><a href="#2-super-xxxx-真的要直接指明父类？" class="headerlink" title="2. [super xxxx]真的要直接指明父类？"></a>2. <code>[super xxxx]</code>真的要直接指明父类？</h4><p>我们使用clang的rewrite指令重写Son.m：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc Son.m</div></pre></td></tr></table></figure>
<p>生成的Son.cpp文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Son_eat(Son * self, SEL _cmd) &#123;</div><div class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Son"</span>))&#125;, sel_registerName(<span class="string">"eat"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一行到底的代码可读性太差，让我们稍稍分解下（由于语法问题我们作了少量语法修改以通过编译，实际作用与原cpp中一致）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static void _I_Son_eat(Son * self, SEL _cmd) &#123;</div><div class="line">    __rw_objc_super superReceiver = (__rw_objc_super)&#123;</div><div class="line">        (__bridge struct objc_object *)(id)self,</div><div class="line">        (__bridge struct objc_object *)(id)class_getSuperclass(objc_getClass(&quot;Son&quot;))&#125;;</div><div class="line">    </div><div class="line">    typedef void *Func(__rw_objc_super *, SEL);</div><div class="line">    Func *func = (void *)objc_msgSendSuper;</div><div class="line">    </div><div class="line">    func(&amp;superReceiver, sel_registerName(&quot;eat&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先修改Son.m运行起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Son.m</div><div class="line"></div><div class="line">- (void)eat &#123;</div><div class="line">//    [super eat];</div><div class="line">    </div><div class="line">  //_I_Son_eat即为重写的函数</div><div class="line">    _I_Son_eat(self, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 输出</div><div class="line">2017-05-15 00:08:37.782519+0800 TestSuper[7460:3810248] Father eat</div></pre></td></tr></table></figure>
<p>没有毛病。</p>
<p>重写的代码里构建了一个<code>__rw_objc_super</code>的结构体，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __rw_objc_super &#123; </div><div class="line">	struct objc_object *object; </div><div class="line">	struct objc_object *superClass; </div><div class="line">    // cpp里的语法，忽略即可</div><div class="line">	__rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该结构体与<code>struct objc_super</code>一致。之后我们将<code>objc_msgSendSuper</code>函数转换为指定参数的函数<code>func</code>进行调用。这里请注意<code>__rw_objc_super superReceiver</code>中的<strong>第二个值</strong>：<code>class_getSuperclass(objc_getClass(&quot;Son&quot;))</code>。</p>
<p>该代码直接指明的类是本类：Son类。但是<code>__rw_objc_super</code>结构体中的<code>superClass</code>并不是本类，而是<strong>通过runtime查找出的父类</strong>。这与我们自己实现的 “直接指明Father为<code>objc_super</code>结构体的<code>super_class</code>值” 最后达到的效果是一样的。</p>
<p>所以，<strong><code>[super xxxx]</code>肯定要通过指明一个类，可以是父类，也可以是本类，来达到正确调用父类方法的目的！</strong>只不过“直接指明”这件事，编译器会帮我们搞定，我们只管写<code>super</code>即可。</p>
<h2 id="clang-rewrite不可靠"><a href="#clang-rewrite不可靠" class="headerlink" title="clang rewrite不可靠"></a>clang rewrite不可靠</h2><h3 id="为何clang不可靠"><a href="#为何clang不可靠" class="headerlink" title="为何clang不可靠"></a>为何clang不可靠</h3><p>clang的rewrite功能所提供的重写后的代码并非编译器（LLVM）转换后的代码，如今的编译器在Xcode开启bitcode功能后会生成一种中间代码：LLVM  Intermediate Representation（LLVM IR）。该代码向上可统一大部分高级语言，向下可支持多种不同架构的CPU，具体可查看<a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="external">LLVM文档</a>。所以我们的目标是从IR代码求证<code>super</code>究竟在做什么事！</p>
<h3 id="查看IR代码"><a href="#查看IR代码" class="headerlink" title="查看IR代码"></a>查看IR代码</h3><p>终端里cd到Son.m文件所在目录，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm Son.m -S -o son.ll</div></pre></td></tr></table></figure>
<p>生成的IR代码比较多，我们挑重点进行查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">%<span class="number">0</span> = type opaque</div><div class="line"></div><div class="line"><span class="comment">// Son的eat方法</span></div><div class="line">define internal <span class="keyword">void</span> @<span class="string">"\01-[Son eat]"</span>(%<span class="number">0</span>*, i8*) #<span class="number">0</span> &#123;</div><div class="line">  %<span class="number">3</span> = alloca %<span class="number">0</span>*, align <span class="number">8</span>    <span class="comment">// 分配一个指针的内存，8字节对齐（声明一个指针变量）</span></div><div class="line">  %<span class="number">4</span> = alloca i8*, align <span class="number">8</span>    <span class="comment">// 分配一个char *的内存（声明一个char *指针变量）</span></div><div class="line">  %<span class="number">5</span> = alloca %<span class="keyword">struct</span>._objc_super, align <span class="number">8</span>    <span class="comment">// 给_objc_super分配内存（声明一个struct._objc_super变量）</span></div><div class="line">  store %<span class="number">0</span>* %<span class="number">0</span>, %<span class="number">0</span>** %<span class="number">3</span>, align <span class="number">8</span>    <span class="comment">// 将第一个参数，id self 写入%3分配的内存中去</span></div><div class="line">  store i8* %<span class="number">1</span>, i8** %<span class="number">4</span>, align <span class="number">8</span>    <span class="comment">// 将_cmd写入%4分配的内存中区</span></div><div class="line">  %<span class="number">6</span> = load %<span class="number">0</span>*, %<span class="number">0</span>** %<span class="number">3</span>, align <span class="number">8</span>   <span class="comment">// 读出%3内存中的数据到%6这个临时变量（%3中存的是self）</span></div><div class="line">  %<span class="number">7</span> = bitcast %<span class="number">0</span>* %<span class="number">6</span> to i8*        <span class="comment">// 将%6变量的类型转换为char *指针类型，指向的还是self</span></div><div class="line">  %<span class="number">8</span> = getelementptr inbounds %<span class="keyword">struct</span>._objc_super, %<span class="keyword">struct</span>._objc_super* %<span class="number">5</span>, i32 <span class="number">0</span>, i32 <span class="number">0</span>    <span class="comment">// 取struct._objc_super变量（%5）中的第0个元素，声明为%8</span></div><div class="line">  store i8* %<span class="number">7</span>, i8** %<span class="number">8</span>, align <span class="number">8</span>    <span class="comment">// 将%7存入%8这个变量中，即把i8* 类型的 self存入了结构体第0个元素中</span></div><div class="line">  %<span class="number">9</span> = load %<span class="keyword">struct</span>.<span class="keyword">_class_t</span>*, %<span class="keyword">struct</span>.<span class="keyword">_class_t</span>** @<span class="string">"OBJC_CLASSLIST_SUP_REFS_$_"</span>, align <span class="number">8</span>    <span class="comment">// 声明%9临时变量为struct._class_t*类型，内容为@"OBJC_CLASSLIST_SUP_REFS_$_"</span></div><div class="line">  %<span class="number">10</span> = bitcast %<span class="keyword">struct</span>.<span class="keyword">_class_t</span>* %<span class="number">9</span> to i8*   <span class="comment">// 将%9的变量强转为char *类型</span></div><div class="line">  %<span class="number">11</span> = getelementptr inbounds %<span class="keyword">struct</span>._objc_super, %<span class="keyword">struct</span>._objc_super* %<span class="number">5</span>, i32 <span class="number">0</span>, i32 <span class="number">1</span>   <span class="comment">// 取struct._objc_super变量（%5）中的第1个元素，声明为%11</span></div><div class="line">  store i8* %<span class="number">10</span>, i8** %<span class="number">11</span>, align <span class="number">8</span>    <span class="comment">// 将%9的变量，即@"OBJC_CLASSLIST_SUP_REFS_$_"存入结构体第1个元素中</span></div><div class="line">  %<span class="number">12</span> = load i8*, i8** @OBJC_SELECTOR_REFERENCES_, align <span class="number">8</span>, !invariant.load !<span class="number">7</span>    <span class="comment">// 将@selector(eat)的引用放入char *类型的%12变量中</span></div><div class="line"></div><div class="line">  <span class="comment">// 函数调用，传入参数为上述生成的struct._objc_super结构体和 @selector(eat)，调用函数objc_msgSendSuper2</span></div><div class="line">  call <span class="keyword">void</span> bitcast (i8* (%<span class="keyword">struct</span>._objc_super*, i8*, ...)* @objc_msgSendSuper2 to <span class="keyword">void</span> (%<span class="keyword">struct</span>._objc_super*, i8*)*)(%<span class="keyword">struct</span>._objc_super* %<span class="number">5</span>, i8* %<span class="number">12</span>)</div><div class="line">  ret <span class="keyword">void</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@<span class="string">"OBJC_CLASS_$_Son"</span> = global %<span class="keyword">struct</span>.<span class="keyword">_class_t</span> &#123; </div><div class="line">                                                %<span class="keyword">struct</span>.<span class="keyword">_class_t</span>* @<span class="string">"OBJC_METACLASS_$_Son"</span>,</div><div class="line">                                                %<span class="keyword">struct</span>.<span class="keyword">_class_t</span>* @<span class="string">"OBJC_CLASS_$_Father"</span>, </div><div class="line">                                                %<span class="keyword">struct</span>._objc_cache* @_objc_empty_cache, </div><div class="line">                                                i8* (i8*, i8*)** null,</div><div class="line">                                                %<span class="keyword">struct</span>.<span class="keyword">_class_ro_t</span>* @<span class="string">"\01l_OBJC_CLASS_RO_$_Son"</span> </div><div class="line">                                              &#125;, section <span class="string">"__DATA, __objc_data"</span>, align <span class="number">8</span></div><div class="line"></div><div class="line"><span class="comment">// 直接存放进入struct._objc_super的变量， 内容为@"OBJC_CLASS_$_Son"</span></div><div class="line">@<span class="string">"OBJC_CLASSLIST_SUP_REFS_$_"</span> = <span class="keyword">private</span> global %<span class="keyword">struct</span>.<span class="keyword">_class_t</span>* @<span class="string">"OBJC_CLASS_$_Son"</span>, section <span class="string">"__DATA, __objc_superrefs, regular, no_dead_strip"</span>, align <span class="number">8</span></div></pre></td></tr></table></figure>
<p>IR的语法其实不难记，还是比较好懂的。这里我们只要对照着看即可：</p>
<ul>
<li>%1，%2，@xxx之类的都是指代变量，理解为变量名就可以了</li>
<li>i8指8位的int类型，即1个字节的char类型。i8<em>就是指char </em>指针</li>
<li>alloca指分配内存，理解为声明一个变量即可，如alloca i8<em>即为一个char </em>的变量</li>
<li>%0在开头的代码里说明了是一个不透明的类型，所以%0*就指代一个万能指针，理解为id即可</li>
<li>store为写入内存</li>
<li>load为从内存中读取出来</li>
<li>bitcast为类型转换</li>
<li>getelementptr inbounds取指定内存偏移</li>
</ul>
<p>代码中既有汇编的赶脚，又有高级语言的味道。基本上注释都补全了，代码中的逻辑和上文中<strong>我们自己实现的/clang重写的</strong>代码基本相似。但是这里注意<code>@&quot;OBJC_CLASSLIST_SUP_REFS_$_&quot;</code>这个变量。</p>
<p><code>@&quot;OBJC_CLASSLIST_SUP_REFS_$_&quot;</code>其实就是对应到<code>struct objc_super</code>结构中的第二个元素：<code>super_class</code>。在IR代码的%11以及后面那一行就是体现。</p>
<p>而<code>@&quot;OBJC_CLASSLIST_SUP_REFS_$_&quot;</code>的定义就是<code>@&quot;OBJC_CLASS_$_Son&quot;</code>这个全局变量。<code>@&quot;OBJC_CLASS_$_Son&quot;</code>全局变量就是Son这个类对象，里面包含了元类：<code>@&quot;OBJC_METACLASS_$_Son&quot;</code>，以及父类：<code>@&quot;OBJC_CLASS_$_Father&quot;</code>，以及其他的一些数据。然而，看到这里，我们发现这和我们自己实现的<code>super</code>，以及clang重写的<code>super</code>都不一样：这里是直接将<code>[Son class]</code>作为<code>struct objc_super</code>的<code>super_class</code>，但是并没有任何调用<code>class_getSuperclass</code>的地方…</p>
<h3 id="查看汇编源码"><a href="#查看汇编源码" class="headerlink" title="查看汇编源码"></a>查看汇编源码</h3><p>但是，这里唯一的一个函数<code>@objc_msgSendSuper2</code>貌似与众不同，与我们之前看到的<code>objc_msgSendSuper</code>相比多了个2，难道是这个函数在作鬼？那就让我们到官方的objc4-709源码里查询下这个函数（位于<code>objc-msg-arm64.s</code>文件中）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ENTRY _objc_msgSendSuper2</div><div class="line">UNWIND _objc_msgSendSuper2, NoFrame</div><div class="line">MESSENGER_START</div><div class="line"></div><div class="line">ldp	x0, x16, [x0]		<span class="comment">// x0 = real receiver, x16 = class</span></div><div class="line">ldr	x16, [x16, #SUPERCLASS]	<span class="comment">// x16 = class-&gt;superclass</span></div><div class="line">CacheLookup NORMAL</div><div class="line"></div><div class="line">END_ENTRY _objc_msgSendSuper2</div></pre></td></tr></table></figure>
<p>这是一段汇编代码，没错，苹果为了提高运行效率，发送消息相关的函数是直接用汇编实现的。</p>
<p>这里我们来简单分析下这个函数：</p>
<ol>
<li><code>ldp x0, x16, [x0]</code>：从x0出读取两个字数据到x0与x16中，根据注释，读取的数据应该是对应的<code>self</code>与<code>[Son class]</code>。</li>
<li><code>ldr x16, [x16, #SUPERCLASS]</code>：将x16的数值+SUPERCLASS值的偏移作为地址，取出该地址的数值保存在x16中。这里的<code>SUPERCLASS</code>定义是<code>#define SUPERCLASS 8</code>，也就是偏移8位，那么取到的应该就是<code>@&quot;OBJC_CLASS_$_Father&quot;</code>这个父类<code>[Father class]</code>到x16中。</li>
<li>执行<code>CacheLookup</code>函数，参数为NORMAL。</li>
</ol>
<p>让我们看看<code>CacheLookup</code>的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/********************************************************************</span></div><div class="line"> *</div><div class="line"> * CacheLookup NORMAL|GETIMP|LOOKUP</div><div class="line"> * </div><div class="line"> * Locate the implementation for a selector in a class method cache.</div><div class="line"> *</div><div class="line"> * Takes:</div><div class="line"> *	 x1 = selector</div><div class="line"> *	 x16 = class to be searched</div><div class="line"> *</div><div class="line"> * Kills:</div><div class="line"> * 	 x9,x10,x11,x12, x17</div><div class="line"> *</div><div class="line"> * On exit: (found) calls or returns IMP</div><div class="line"> *                  with x16 = class, x17 = IMP</div><div class="line"> *          (not found) jumps to LCacheMiss</div><div class="line"> *</div><div class="line"> ********************************************************************/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NORMAL 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GETIMP 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOKUP 2</span></div><div class="line"></div><div class="line">.macro CacheLookup</div><div class="line">	<span class="comment">// x1 = SEL, x16 = isa</span></div><div class="line">	ldp	x10, x11, [x16, #CACHE]	<span class="comment">// x10 = buckets, x11 = occupied|mask</span></div><div class="line">	and	w12, w1, w11		<span class="comment">// x12 = _cmd &amp; mask</span></div><div class="line">	add	x12, x10, x12, LSL #<span class="number">4</span>	<span class="comment">// x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4)</span></div><div class="line"></div><div class="line">	ldp	x9, x17, [x12]		<span class="comment">// &#123;x9, x17&#125; = *bucket</span></div><div class="line"><span class="number">1</span>:	cmp	x9, x1			<span class="comment">// if (bucket-&gt;sel != _cmd)</span></div><div class="line">	b.ne	<span class="number">2f</span>			<span class="comment">//     scan more</span></div><div class="line">	CacheHit $<span class="number">0</span>			<span class="comment">// call or return imp</span></div><div class="line">	</div><div class="line"><span class="number">2</span>:	<span class="comment">// not hit: x12 = not-hit bucket</span></div><div class="line">	CheckMiss $<span class="number">0</span>			<span class="comment">// miss if bucket-&gt;sel == 0</span></div><div class="line">	cmp	x12, x10		<span class="comment">// wrap if bucket == buckets</span></div><div class="line">	b.eq	<span class="number">3f</span></div><div class="line">	ldp	x9, x17, [x12, #<span class="number">-16</span>]!	<span class="comment">// &#123;x9, x17&#125; = *--bucket</span></div><div class="line">	b	<span class="number">1b</span>			<span class="comment">// loop</span></div><div class="line"></div><div class="line"><span class="number">3</span>:	<span class="comment">// wrap: x12 = first bucket, w11 = mask</span></div><div class="line">	add	x12, x12, w11, UXTW #<span class="number">4</span>	<span class="comment">// x12 = buckets+(mask&lt;&lt;4)</span></div><div class="line"></div><div class="line">	<span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span></div><div class="line">	<span class="comment">// The slow path may detect any corruption and halt later.</span></div><div class="line"></div><div class="line">	ldp	x9, x17, [x12]		<span class="comment">// &#123;x9, x17&#125; = *bucket</span></div><div class="line"><span class="number">1</span>:	cmp	x9, x1			<span class="comment">// if (bucket-&gt;sel != _cmd)</span></div><div class="line">	b.ne	<span class="number">2f</span>			<span class="comment">//     scan more</span></div><div class="line">	CacheHit $<span class="number">0</span>			<span class="comment">// call or return imp</span></div><div class="line">	</div><div class="line"><span class="number">2</span>:	<span class="comment">// not hit: x12 = not-hit bucket</span></div><div class="line">	CheckMiss $<span class="number">0</span>			<span class="comment">// miss if bucket-&gt;sel == 0</span></div><div class="line">	cmp	x12, x10		<span class="comment">// wrap if bucket == buckets</span></div><div class="line">	b.eq	<span class="number">3f</span></div><div class="line">	ldp	x9, x17, [x12, #<span class="number">-16</span>]!	<span class="comment">// &#123;x9, x17&#125; = *--bucket</span></div><div class="line">	b	<span class="number">1b</span>			<span class="comment">// loop</span></div><div class="line"></div><div class="line"><span class="number">3</span>:	<span class="comment">// double wrap</span></div><div class="line">	JumpMiss $<span class="number">0</span></div><div class="line">	</div><div class="line">.endmacro</div></pre></td></tr></table></figure>
<p>具体的<code>CacheLookup</code>我们这里就不再展开了，我们只关心这里是从哪里查找方法的。在注释中，明确说到这是一个“去类的方法缓存中寻找方法实现”的函数，参入的参数是x1中的selector，x16中的class<strong>(class to be searched 就是说从这个类中开始查找)</strong>，而这时候的x16，恰恰是我们刚才在<code>_objc_msgSendSuper2</code>存入的父类<code>[Father class]</code>，因此，<strong>方法会从这个类中开始查找</strong>。</p>
<h3 id="整体调用流程"><a href="#整体调用流程" class="headerlink" title="整体调用流程"></a>整体调用流程</h3><p>从手动实现-&gt;查看clang重写-&gt;查看IR码-&gt;查看汇编源码这几个过程分析下来，我们总算是把这条真实的<code>super</code>调用链路搞搞清楚了：</p>
<ol>
<li>编译器指定一个<code>struct._objc_super</code>结构体， 结构体中<code>self</code>为接收对象，<strong>直接指明</strong>自身的类为结构体第二个class类型的值。</li>
<li>调用<code>_objc_msgSendSuper2</code>函数，传入上述<code>struct._objc_super</code>结构体。</li>
<li>在<code>_objc_msgSendSuper2</code>函数中直接通过偏移量<strong>直接查找</strong>父类。</li>
<li>调用<code>CacheLookup</code>函数去父类中查找指定方法。</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以，从真实的IR代码中，<strong><code>super</code>关键字其实是直接指明本类Son，再结合<code>_objc_msgSendSuper2</code>函数直接获取父类去查找方法的，而并非像clang重写的那样，指明本类，再通过runtime查找父类。</strong></p>
<p>其实先指明本类，再通过runtime查找父类，也是没有问题的，这还可以避免一些运行时“更改父类”的情况。但是LLVM的做法应该是有他的道理的，可能是出于性能考虑？</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">9</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj2wsm49d000av4vs92ntehk2" data-title="super关键字帮我们做了什么？" data-url="http://yoursite.com/2017/05/18/super-keyword/" site-name="daiyi"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/08/13/customFontIssues/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/05/01/ChangeYourAppIcons2/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/maybeisyi" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/5721363654/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="mailto:daybyte@163.com" title="Email" target="_blank"><i class="icon icon-email"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 戴奕的个人博客<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>